# Отчет по Лабораторной Работе №3: Синхронизация Потоков с Критическими Секциями и Событиями
## Обзор Задачи
Целью данной лабораторной работы была разработка многопоточного консольного приложения, состоящего из одного главного потока (main) и нескольких дочерних потоков (marker). Основная задача заключалась в реализации сложной координации и синхронизации между этими потоками при работе с общим массивом целых чисел, используя критические секции и объекты событий (Events). Отдельное внимание уделялось обработке ситуаций, когда потоки marker не могут продолжить свою работу.

## Функциональные Требования

### Поток main

Поток main выполняет роль координатора:

Инициализация: Запрашивает у пользователя размер массива и количество потоков marker. Выделяет память под массив и инициализирует его нулями.  
Создание и запуск marker-потоков: Создает указанное количество потоков marker, каждому передает его уникальный ID.  
Начальный сигнал: Подает сигнал всем marker-потокам для одновременного старта их работы.  
Цикл координации: В цикле выполняет следующие действия:  
Ожидание "застревания": Ждет, пока все активные marker-потоки не сообщат о невозможности продолжения работы (то есть, не смогут найти свободные ячейки в массиве для пометки).
Вывод состояния массива: Отображает текущее содержимое общего массива.  
Запрос на завершение потока: Запрашивает у пользователя, какой из marker-потоков следует завершить.  
Сигнал на завершение: Подает выбранному marker-потоку сигнал о необходимости завершения работы.  
Ожидание завершения: Ждет фактического завершения выбранного marker-потока.   
Повторный вывод массива: Снова отображает состояние массива после завершения потока (для контроля очистки пометок).  
Сигнал на продолжение: Подает сигнал оставшимся активным marker-потокам, чтобы они продолжили свою работу.  
Финальное завершение: После того как все marker-потоки завершат работу, main-поток также завершается, очищая все системные ресурсы.

### Поток marker
Каждый marker-поток выполняет свою независимую, но синхронизированную работу:

Ожидание старта: Начинает свою основную работу только после получения стартового сигнала от main-потока.  
Инициализация генератора случайных чисел: Использует свой уникальный ID для инициализации генератора случайных чисел (srand), обеспечивая разные последовательности для разных потоков.  
Рабочий цикл:   
В каждом цикле:  
Генерирует случайный индекс в пределах массива.   
Попытка пометки:  
Если элемент массива по этому индексу равен нулю (свободен), marker-поток помечает его своим ID, имитируя работу (задержка Sleep(5) мс до и после пометки).  
Если элемент уже занят (не равен нулю) или был занят другим потоком во время задержки, поток считается "застрявшим".  
Обработка "застревания":  
Выводит информацию о том, какой элемент не удалось пометить.  
Сигнализирует main: Подает сигнал main-потоку, что он "застрял" и не может продолжить работу.  
Ожидание инструкции: Ждет ответного сигнала от main-потока (либо на продолжение работы, либо на завершение).  
Завершение работы по сигналу: Если от main-потока получен сигнал на завершение:  
Очистка пометок: Заполняет нулями все элементы массива, которые были помечены данным marker-потоком.  
Завершает свою работу.  
Продолжение работы по сигналу: Если от main-потока получен сигнал на продолжение, marker-поток возвращается к своему рабочему циклу.


##  Реализация
Программа реализована на C++ с использованием Windows API для многопоточности и синхронизации.


## Общие Ресурсы и Синхронизация
Массив g_array: Используется std::vector<int> как общий массив. Доступ к нему защищается критической секцией g_array_cs, чтобы избежать состояний гонки при чтении и записи.
Счетчик активных потоков g_active_markers_count: Отслеживает количество работающих marker-потоков. Доступ к нему защищен критической секцией g_active_markers_cs.
Консольный вывод: Вывод на консоль также защищается критической секцией g_console_cs для предотвращения перемешивания сообщений от разных потоков.

### Объекты Событий (HANDLE):
g_start_all_markers_event: Событие с ручным сбросом (CreateEvent(NULL, TRUE, FALSE, NULL)), используемое main для одновременного запуска всех marker-потоков.
g_marker_stuck_events: Вектор событий с автоматическим сбросом (CreateEvent(NULL, FALSE, FALSE, NULL)). Каждый marker-поток имеет свое событие в этом векторе, которое он сигнализирует main, когда "застревает".
g_marker_continue_terminate_events: Вектор событий с автоматическим сбросом. Каждый marker-поток имеет свое событие, которое main сигнализирует, чтобы приказать потоку продолжить или завершиться.
Механизмы Координации

WaitForSingleObject: Используется как marker-потоками для ожидания стартового сигнала или сигнала на продолжение/завершение, так и main-потоком для ожидания полного завершения выбранного marker-потока.
WaitForMultipleObjects: Главный поток использует эту функцию для ожидания, пока все активные marker-потоки подадут сигнал о том, что они "застряли". Важно помнить об ограничении MAXIMUM_WAIT_OBJECTS (64) для этой функции, что может потребовать более сложной логики при очень большом количестве потоков.
SetEvent: Используется для перевода объектов событий в сигнальное состояние, тем самым уведомляя ожидающие потоки.
Обработка "Тупиков" (Deadlocks)

Хотя явной ситуации взаимоблокировки, связанной с круговым ожиданием ресурсов, в данном сценарии не возникает благодаря правильному использованию критических секций (захват-освобождение) и событий для асинхронной координации, задача подразумевает, что потоки могут попасть в состояние, когда они не могут выполнить свою работу (все ячейки массива заняты). Это "застревание" обрабатывается через систему сигналов событий: marker-потоки сообщают о "застревании", а main-поток реагирует, управляя их жизненным циклом. Это предотвращает бесполезное потребление ресурсов "застрявшими" потоками.

# Вывод
Реализованное решение успешно демонстрирует применение критических секций для безопасного доступа к общим данным и объектов событий для сложной координации между несколькими потоками. Программа эффективно управляет жизненным циклом дочерних потоков, реагируя на их состояния ("застревание") и динамически принимая решения о продолжении или завершении их работы. Это является хорошей иллюстрацией принципов многопоточного программирования и синхронизации в среде Windows.
